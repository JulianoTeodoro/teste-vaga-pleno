## Documenta√ß√£o t√©cnica das atividades solicitadas no teste.


As funcionalidades foram desenvolvidas em .NET 8 no back-end e React com React Query no front-end para controle de estado ass√≠ncrono, garantindo sincroniza√ß√£o com o backend e experi√™ncia fluida ao usu√°rio.

### Tarefa 1 : Completar a Tela de Cliente

Contexto: Anteriormente, o m√≥dulo Clientes do sistema permitia apenas o cadastro, listagem e exclus√£o de clientes.
Com esta entrega, foi implementada a se√ß√£o de edi√ß√£o de clientes, permitindo ao usu√°rio atualizar as informa√ß√µes de um cliente j√° existente, com intera√ß√£o direta com o endpoint PUT /api/clientes/{id} da API.

#### Back-End

üöÄ Endpoint
PUT /api/clientes/{id}

Atualiza as informa√ß√µes de um cliente existente.

```
{
  "nome": "Jo√£o da Silva",
  "telefone": "11999998888",
  "endereco": "Rua das Flores, 123",
  "mensalista": true,
  "valorMensalidade": 250.00
}
```
üîπ Respostas poss√≠veis

| Codigo | Tipo | Descri√ß√£o |
|:-----------:|:------------|------------:|
| 200    | OK    | Cliente atualizado com sucesso    |
| 404  | Not Found | Cliente n√£o cadastrado!!  |
| 409  | Conflict  | Cliente j√° existente.  |
| 400  | BadRequest  | Mensagem gen√©rica para erros de valida√ß√£o  |

````
{
  "id": "8df5a7c4-90f3-4d7e-b4b3-15a9a2b7990e",
  "nome": "Jo√£o da Silva",
  "telefone": "11999998888",
  "endereco": "Rua das Flores, 123",
  "mensalista": true,
  "valorMensalidade": 250.0
}
````

Decis√µes t√©cnicas :
````
Segrega√ß√£o de responsabilidades por camadas (Controller, Business, Repository): Foi adotada uma arquitetura em camadas, seguindo o padr√£o Clean Architecture / DDD simplificado, evitando duplica√ß√£o de l√≥gica e mant√©m o c√≥digo mais f√°cil de testar e evoluir.

Utiliza√ß√£o de DTOs: Foi criada a classe ClienteUpdateDto para receber apenas os campos edit√°veis (Nome, Telefone, Endere√ßo, Mensalista, ValorMensalidade).
Essa decis√£o impede exposi√ß√£o direta da entidade Cliente e reduz riscos de atualiza√ß√µes indevidas em propriedades sens√≠veis.

Valida√ß√£o de exist√™ncia e unicidade: A valida√ß√£o de unicidade (Nome + Telefone) foi movida para a camada de neg√≥cio antes da atualiza√ß√£o, utilizando o m√©todo AnyAsync.

Padroniza√ß√£o de respostas HTTP : Foram utilizadas respostas HTTP adequadas para cada cen√°rio, seguindo as boas pr√°ticas REST e melhorando a comunica√ß√£o entre front-end e back-end.

````

#### Front-End

O c√≥digo foi implementado dentro do componente principal ClientesPage.jsx.

##### Principais responsabilidades:

Incluir nova se√ß√£o de edi√ß√£o;
Controlar estado de filtros, formul√°rios e a√ß√µes (editar/excluir).

Decis√µes t√©cnicas: 

````
Separa√ß√£o de estado entre cria√ß√£o e edi√ß√£o

Foram criados dois objetos de estado distintos:
form (para novo cliente) e formEditar (para edi√ß√£o).

Essa decis√£o evita conflito entre os dois formul√°rios e garante que os dados de edi√ß√£o n√£o interfiram no formul√°rio de cria√ß√£o.

Controle condicional de exibi√ß√£o da se√ß√£o de edi√ß√£o: A vari√°vel booleana editar foi adicionada para exibir ou ocultar o formul√°rio de edi√ß√£o.
Mant√©m a tela limpa e evita m√∫ltiplas edi√ß√µes simult√¢neas.

Reutiliza√ß√£o de l√≥gica de formul√°rio com handleChange: A fun√ß√£o handleChange foi centralizada para lidar com diferentes tipos de input (text, checkbox, number, select).
Reduz duplica√ß√£o de c√≥digo e melhora manuten√ß√£o futura.

Integra√ß√£o com o backend via React Query (useMutation)

Atualiza√ß√£o autom√°tica da lista ap√≥s edi√ß√£o

Ap√≥s uma edi√ß√£o bem-sucedida, o cache da query ['clientes'] √© invalidado: Essa decis√£o elimina a necessidade de recarregar manualmente a lista e mant√©m os dados sempre sincronizados com o servidor.

Mensagens de sucesso e erro s√£o tratadas dentro da pr√≥pria mutation (onSuccess / onError).

````

### Tarefa 2 : Completar a Tela de Veiculos

Contexto: Anteriormente a aplica√ß√£o s√≥ atualizava o modelo do veiculo, foi solicitado que seja incluido os campos "Placa" e "Ano", e que seja possivel alterar o dono do ve√≠culo.

Com esta entrega, foi implementada a se√ß√£o de edi√ß√£o de veiculos, permitindo ao usu√°rio atualizar as informa√ß√µes de um veiculo j√° existente, com intera√ß√£o direta com o endpoint PUT /api/veiculos/{id} da API.

#### Back-End

üöÄ Endpoint
PUT /api/veiculos/{id}

Atualiza as informa√ß√µes de um veiculo existente.

```
{
  "placa": "HEX-0313",
  "modelo": "Uno",
  "ano":2024,
  "clienteid":"3fa85f64-5717-4562-b3fc-2c963f66afa6"
}
```
üîπ Respostas poss√≠veis

| Codigo | Tipo | Descri√ß√£o |
|:-----------:|:------------|------------:|
| 200    | OK    | Veiculo atualizado com sucesso.    |
| 404  | Not Found | Veiculo n√£o existe!!  |
| 409  | Conflict  | Placa j√° existe.  |
| 400  | BadRequest  | Placa inv√°lida.  |

````
{
  "id": "8df5a7c4-90f3-4d7e-b4b3-15a9a2b7990e",
  "placa": "HEX-0313",
  "modelo": "Uno",
  "ano":2024,
  "clienteid":"3fa85f64-5717-4562-b3fc-2c963f66afa6"
}
````

Decis√µes t√©cnicas: 

````
Segrega√ß√£o de responsabilidades por camadas (Controller, Business, Repository): Foi adotada uma arquitetura em camadas, seguindo o padr√£o Clean Architecture / DDD simplificado, evitando duplica√ß√£o de l√≥gica e mant√©m o c√≥digo mais f√°cil de testar e evoluir.

Valida√ß√£o e normaliza√ß√£o de placa: Foi utilizado o servi√ßo _placa para sanitizar (remover espa√ßos e formata√ß√µes) e validar o padr√£o da placa antes de qualquer opera√ß√£o de banco. Essa decis√£o previne inconsist√™ncias de formato e duplicidades l√≥gicas no cadastro de ve√≠culos.

Regra de unicidade da Placa: Antes de salvar, a aplica√ß√£o garante que nenhuma outra entidade com Id diferente possua a mesma placa.

-- Controle de vig√™ncia Cliente‚ÄìVe√≠culo

   Quando ocorre troca de cliente:
      A vig√™ncia atual √© encerrada (definindo DtFim).
      Uma nova rela√ß√£o √© criada com data de in√≠cio atual.
      Essa abordagem preserva o hist√≥rico de associa√ß√µes, permitindo rastrear qual cliente possu√≠a o ve√≠culo em cada per√≠odo.

Padroniza√ß√£o das respostas HTTP: Foram mantidos os retornos RESTful conforme boas pr√°ticas.
````

#### Front-End

##### Principais responsabilidades:

Incluir novo modal de Edi√ß√£o;
Incluir os campos Placa, Ano e altera√ß√£o de usu√°rios.

Decis√µes t√©cnicas: 

````
Edi√ß√£o via Modal: A antiga abordagem com prompts foi substitu√≠da por um componente modal que exibe um formul√°rio completo de edi√ß√£o.
O modal cont√©m campos para: Placa, Modelo, Ano, Cliente associado (select din√¢mico)

Esse modal √© exibido quando o usu√°rio clica em ‚ÄúEditar‚Äù e fechado ap√≥s salvar ou cancelar.

Amplia√ß√£o dos Campos Edit√°veis: Anteriormente, apenas o Modelo podia ser alterado.
Agora, os campos Ano e ClienteId tamb√©m podem ser modificados.
Isso permitiu alinhar o front com a l√≥gica de neg√≥cio implementada no back-end (que atualiza vig√™ncias e valida placas).

Integra√ß√£o com React Query: A tela faz uso intensivo de React Query, que garante controle reativo dos dados:

useQuery ‚Üí Busca clientes e ve√≠culos.
useMutation ‚Üí Cria, atualiza e remove ve√≠culos.
invalidateQueries ‚Üí Atualiza automaticamente a listagem ap√≥s opera√ß√µes de CRUD.

Isso elimina a necessidade de recarregar a p√°gina manualmente ap√≥s qualquer altera√ß√£o.

Estado Local Estruturado: 
Foram adicionados dois estados distintos para formular os dados:
form ‚Üí Para cria√ß√£o de ve√≠culos.
editarForm ‚Üí Para edi√ß√£o (utilizado dentro do modal).
Al√©m disso, o estado editar controla a exibi√ß√£o do modal.

Feedback Visual e UX: Mensagens de sucesso e erro s√£o exibidas com alertas descritivos, mas o c√≥digo est√° preparado para futura integra√ß√£o com toasts/snackbars. Os bot√µes ‚ÄúSalvar‚Äù e ‚ÄúCancelar‚Äù dentro do modal trazem controle direto sobre o fluxo de edi√ß√£o, evitando erros de navega√ß√£o.

```` 

### Tarefa 3 : Melhorar Upload CSV

Contexto: Anteriormente, a API realizava a importa√ß√£o de arquivos CSV diretamente na controller, com o arquivo sendo enviado via form-data (upload direto de arquivo).
Essa abordagem tornava a controller respons√°vel por m√∫ltiplas responsabilidades ‚Äî tratamento de arquivo, l√≥gica de neg√≥cio e retorno de resultados ‚Äî o que dificultava manuten√ß√£o, testes unit√°rios e reaproveitamento de c√≥digo.

Com essa entrega ser√° possivel enviar o CSV em base64 dentro do corpo da requisi√ß√£o, facilitando a integra√ß√£o.

#### Back-End

üöÄ Endpoint
POST /api/import/csv

Realiza a importa√ß√£o de veiculos e clientes.

```
{
  "base64":"cGxhY2EsbW9kZWxvLGFubyxjbGllbnRlX2lkZW50aWZpY2Fkb3IsY2xpZW50ZV9ub21lLGNsaWVudGVfdGVsZWZvbmUsY2xpZW50ZV9lbmRlcmVjbyxtZW5zYWxpc3RhLHZhbG9yX21lbnNhbGlkYWRlDQpCUkExQTIzLEdvbCwyMDE5LENMSS0wMDEsSm/Do28gU291emEsMzEgOTk5OTktMDAwMSwiUnVhIEEsIDEyMyIsdHJ1ZSwxODkuOTANClJDSDJCNDUsT25peCwyMDIwLENMSS0wMDIsTWFyaWEgTGltYSwzMSA5ODg4OC0wMDAyLCJBdi4gQiwgNDU2IixmYWxzZSwNCkFCQzFEMjMsSEIyMCwyMDE4LENMSS0wMDEsSm/Do28gU291emEsMzEgOTk5OTktMDAwMSwiUnVhIEEsIDEyMyIsdHJ1ZSwxODkuOTANCkFBQS0xMTExLFVubywyMDE1LENMSS0wMDMsQ2FybG9zIFNpbHZhLCgzMSkgOTc3NzctMDAwMywiUnVhIEMsIDc4OSIsdHJ1ZSwxNTkuOTANCklOVi1YWFhYLENhcnJvLDIwMjAsQ0xJLTAwNCxFcnJvIFBsYWNhLDMxIDk2NjY2LTAwMDQsIlJ1YSBYLCAwMDAiLHRydWUsMTIwLjAwDQpCUkExQTIzLEdvbCwyMDE5LENMSS0wMDEsRHVwbGljYWRhLDMxIDk1NTU1LTAwMDUsIlJ1YSBEdXAsIDEyIix0cnVlLDEwMC4wMA0K"
}

```
üîπ Respostas poss√≠veis

| Codigo | Tipo | Descri√ß√£o |
|:-----------:|:------------|------------:|
| 200    | OK    | Importado com sucesso.    |
| 400  | BadRequest  | Placa inv√°lida. / Placa inv√°lida para importa√ß√£o. / Arquivo invalido. |

````
{
  "qtProcessados": 6,
  "qtInseridos": 6,
  "qtErros": 0,
  "erros": []
}
````


Decis√µes Tecnicas: 

```` 

Segrega√ß√£o de responsabilidades por camadas (Controller, Business, Repository): Foi adotada uma arquitetura em camadas, seguindo o padr√£o Clean Architecture / DDD simplificado, evitando duplica√ß√£o de l√≥gica e mant√©m o c√≥digo mais f√°cil de testar e evoluir.

Valida√ß√£o e normaliza√ß√£o de placa: Foi utilizado o servi√ßo _placa para sanitizar (remover espa√ßos e formata√ß√µes) e validar o padr√£o da placa antes de qualquer opera√ß√£o de banco. Essa decis√£o previne inconsist√™ncias de formato e duplicidades l√≥gicas no cadastro de ve√≠culos.

Formato de upload: Envio em base64 dentro do corpo (ImportarCsv.base64), com objetivo de facilitar envio via JSON, integra√ß√µes automatizadas e elimina necessidade de multipart/form-data.

Processamento do CSV: Uso de StreamReader com MemoryStream para decodificar base64, evitando grava√ß√£o tempor√°ria em disco e melhora performance.

Controle de erros	Try/catch linha a linha: o registro de exce√ß√µes espec√≠ficas permite continuar o processamento mesmo com linhas inv√°lidas.

Estrutura de retorno: Novo objeto ImportacaoResponse com lista detalhada de erros aumenta a rastreabilidade e melhora a experi√™ncia do usu√°rio final.

```` 

#### Front-End

##### Principais responsabilidades:
Adaptar o envio do arquivo CSV para o novo formato base64.
Linhas e mensagens de erro detalhadas.
Melhorar a usabilidade e experi√™ncia visual da tela de importa√ß√£o.

Decis√µes Tecnicas: 

```` 

Formato de envio: Convers√£o do arquivo para Base64 e envio via JSON (application/json), compatibilidade com o novo padr√£o da API e facilidade de integra√ß√£o entre sistemas.
Leitura de arquivo: Uso do FileReader para convers√£o local, evitando upload f√≠sico de arquivo e torna o processo mais r√°pido e seguro.
Renderiza√ß√£o de resultado: exibi√ß√£o de campos separados (processados, inseridos, erros), melhora a clareza das informa√ß√µes exibidas.
Listagem de erros: Renderiza√ß√£o de cada erro em um card visual (linha + motivo), facilitando identifica√ß√£o de falhas e depura√ß√£o do CSV.

```` 


### Tarefa 4 : Faturamento Parcial

Contexto: Anteriormente, a API associava cada ve√≠culo a apenas um √∫nico cliente ‚Äúdono‚Äù, sem controle hist√≥rico de trocas de titularidade.
Com isso, o faturamento mensal considerava apenas o cliente atual do ve√≠culo, sem levar em conta mudan√ßas de cliente no meio do m√™s.

Consequentemente:

O cliente antigo pagava o m√™s inteiro, mesmo tendo ficado com o ve√≠culo apenas parte dele. O novo cliente n√£o era faturado proporcionalmente ao per√≠odo em que assumiu o ve√≠culo.

Para resolver isso, foi criada a tabela ClienteVeiculoVigencia, respons√°vel por registrar a vig√™ncia da rela√ß√£o entre cliente e ve√≠culo, com data de in√≠cio e t√©rmino.

Essa estrutura permitiu implementar regras de faturamento proporcional, de modo que a fatura mensal refletisse somente os dias em que o ve√≠culo esteve vinculado ao cliente.

#### SQL

##### Tabela criada: 
````
create table "public"."cliente_veiculo_vigencia"(
  id uuid primary key default uuid_generate_v4(),
  cliente_id uuid not null references "public"."cliente"(id),
  veiculo_id uuid not null references "public"."veiculo"(id),
  data_inicio timestamp not null,
  data_fim timestamp
);
````


#### Back-End

üß© Nova Estrutura de Dados

```` 
public class ClienteVeiculoVigencia
{
    public Guid Id { get; set; } = Guid.NewGuid();

    [Required]
    public Guid ClienteId { get; set; }
    [JsonIgnore]
    public Cliente Cliente { get; set; }

    [Required]
    public Guid VeiculoId { get; set; }
    [JsonIgnore]
    public Veiculo Veiculo { get; set; }

    [Required]
    public DateTime DtInicio { get; set; }
    public DateTime? DtFim { get; set; }
}
```` 


Decis√µes Tecnicas: 

```` 
Persist√™ncia de hist√≥rico de vig√™ncias: 
Implementada a entidade ClienteVeiculoVigencia e respectivo reposit√≥rio EF, e foi criada nova tabela no banco Postgres.
Sempre que um ve√≠culo muda de cliente, a vig√™ncia anterior √© encerrada (DtFim = DateTime.Now) e uma nova √© criada (DtInicio = DateTime.Now).

Segrega√ß√£o de responsabilidades por camadas (Controller, Business, Repository): Foi adotada uma arquitetura em camadas, seguindo o padr√£o Clean Architecture / DDD simplificado, evitando duplica√ß√£o de l√≥gica e mant√©m o c√≥digo mais f√°cil de testar e evoluir.

C√°lculo proporcional: Determina os dias efetivos de vig√™ncia dentro do m√™s da compet√™ncia (DtInicio e DtFim comparados com o intervalo do m√™s).

O valor proporcional √© calculado por: 
    valorProporcional += valorMensal * diasAtivos / totalDiasMes;
O valor √© arredondado para duas casas decimais.

Idempot√™ncia: Antes de gerar uma nova fatura, o sistema verifica se j√° existe fatura para aquele cliente e compet√™ncia.

Relacionamento Fatura-Ve√≠culo: Cada fatura cont√©m todos os ve√≠culos ativos do cliente durante o per√≠odo, garantindo rastreabilidade do faturamento.

Mensagens de observa√ß√£o: A fatura inclui observa√ß√£o padr√£o informando que foi gerada com sucesso, incluindo o total de dias faturados.

```` 

#### Front-End

##### Principais responsabilidades:

N√£o houve altera√ß√£o no front-end.

----------------------------------------------------------
### Stack de Refer√™ncia
- **Backend**: .NET 8 Web API + EF Core + PostgreSQL  
- **Frontend**: React (Vite) + React Router + React Query  
- **Sem containers**: a conex√£o √© configurada diretamente em `appsettings.json`.  

> √â permitido substituir React por Angular/Vue e/ou trocar o ORM, desde que o escopo seja mantido e as decis√µes sejam explicadas no README. O boilerplate fornecido est√° em React com JavaScript.  

### Execu√ß√£o Local

#### Banco PostgreSQL
1. Crie um banco local (ex.: `parking_test`) e ajuste a `ConnectionString` em `appsettings.json`, se necess√°rio.  
2. Rode o seed pelo terminal (bash/WSL):  
   ```bash
   psql -h localhost -U postgres -d parking_test -f scripts/seed.sql
   ```  
   Caso utilize Windows sem WSL, execute o script pelo gerenciador de banco de dados de sua prefer√™ncia (ex.: DBeaver).  

#### Backend
```bash
cd src/backend
dotnet restore
dotnet run
```
A API ser√° iniciada (por padr√£o) em `http://localhost:5000`. Swagger ativado em `/swagger`.  

#### Frontend
```bash
cd src/frontend
npm install
npm run dev
```
A aplica√ß√£o ficar√° dispon√≠vel em `http://localhost:5173`.  
Configure `VITE_API_URL` caso seja necess√°rio apontar para outra porta.  

### 4.3 Estrutura de Pastas
```
/src/backend        -> API .NET 8
/src/frontend       -> React (Vite)
/scripts/seed.sql   -> Cria√ß√£o e seed do banco
/scripts/exemplo.csv-> CSV de exemplo
```

